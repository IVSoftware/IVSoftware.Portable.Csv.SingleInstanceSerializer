
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Text.RegularExpressions;

namespace IVSoftware.Portable.Csv
{
    public static class Extensions
    {
        /// <summary>
        /// Enumerates the public R/W property names of an instance of @type as comma-delimites string.
        /// </summary>
        /// <returns>Comma delimited list of names.</returns>
        public static string GetCsvHeader(this Type @type)
        {
            KnownTypeInfo info;
            if (!KnownTypeDict.TryGetValue(@type, out info))
            {
                info = new KnownTypeInfo(@type);
            }
            return info.CsvHeader;
        }
        /// <summary>
        /// Enumerates the public R/W property names of an instance of @type as string array.
        /// </summary>
        /// <returns>String array of names.</returns>
        public static string[] GetCsvHeaderArray(this Type @type)
        {
            KnownTypeInfo info;
            if (!KnownTypeDict.TryGetValue(@type, out info))
            {
                info = new KnownTypeInfo(@type);
            }
            return info.CsvHeaderArray;
        }
        /// <summary>
        /// Enumerates the public R/W property names of an instance of @type.
        /// </summary>
        /// <returns>String array of names.</returns>
        public static Dictionary<string, PropertyInfo> GetCsvPropertyMap(this Type @type)
        {
            KnownTypeInfo info;
            if (!KnownTypeDict.TryGetValue(@type, out info))
            {
                info = new KnownTypeInfo(@type);
            }
            return info.CsvPropertyMap;
        }

        const string IGNORE_ESCAPED_COMMAS_PATTERN = @",(?=(?:[^""]*""[^""]*"")*(?![^""]*""))";

        /// <summary>
        /// Strict deserialization of an instance of @type from comma delimited string
        /// when header line is generated by GetCsvHeader() or is identical to it.
        /// </summary>
        /// <returns>Instance of type T</returns>
        public static T FromCsvLine<T>(this Type @type, string csvLine)
            where T : new()
        {
            if (csvLine == type.GetCsvHeader())
            {
                // Can't make an instance of T from the header row.
                return default;
            }
            else
            {
                var CsvHeaderNames = type.GetCsvHeaderArray();
                var newT = Activator.CreateInstance<T>();
                var values = Regex.Split(csvLine, IGNORE_ESCAPED_COMMAS_PATTERN);
                for (int i = 0; i < CsvHeaderNames.Length; i++)
                {
                    var propertyName = CsvHeaderNames[i];
                    var value = removeOutsideQuotes(values[i]);
                    if (@type.GetProperty(propertyName) is PropertyInfo pi)
                    {
                        setValue(newT, value, pi);
                    }
                }
                return newT;
            }
        }

        /// <summary>
        /// Fuzzy deserialization of an instance of @type from comma delimited string, meaning
        /// that it's tolerant of names in header that aren't directly mapped to the object.
        /// </summary>
        /// <returns>Instance of type T</returns>
        public static T Extract<T>(this Type @type, string unqualifiedHeader, string csvLine, bool ignoreCase = false)
            where T : new()
        {
            if (csvLine == type.GetCsvHeader())
            {
                // Can't make an instance of T from the header row.
                return default;
            }
            else
            {
                var csvHeaderNames = unqualifiedHeader.Split(',').Select(_ => _.Trim()).ToArray();
                var map = type.GetCsvPropertyMap();
                var newT = Activator.CreateInstance<T>();
                var values = Regex.Split(csvLine, IGNORE_ESCAPED_COMMAS_PATTERN);
                for (int i = 0; i < csvHeaderNames.Length; i++)
                {
                    var propertyName = csvHeaderNames[i];
                    if (map.TryGetValue(ignoreCase ? propertyName.ToLower() : propertyName, out var propertyInfo))
                    {
                        var stringValue = removeOutsideQuotes(values[i]);

                        setValue(newT: newT, stringValue: stringValue, propertyInfo: propertyInfo);
                    }
                }
                return newT;
            }
        }

        private static string removeOutsideQuotes(string s)
        {
            if (s.Contains(',') && s.StartsWith("\"") && s.EndsWith("\""))
            {
                return s.Substring(1, s.Length - 2);
            }
            else return s;
        }

        private static void setValue<T>(T newT, string stringValue, PropertyInfo propertyInfo) where T : new()
        {
            Type propertyType;
            // For Nullable types, we care only about the underlying type.
            if (Nullable.GetUnderlyingType(propertyInfo.PropertyType) is Type underlyingType)
            {
                propertyType = underlyingType;
            }
            else
            {
                propertyType = propertyInfo.PropertyType;
            }

            if (propertyType.Equals(typeof(String)))
            {
                // For type String, assign the value even if it's empty or null
                propertyInfo.SetValue(newT, stringValue);
            }
            else
            {
                // If the value is empty, don't assign anything
                if (string.IsNullOrEmpty(stringValue))
                {
                    return;
                }
                else
                {
                    var method = propertyType.GetMethod("Parse", new[] { typeof(string) });
                    if (method?.IsStatic == true)
                    {
                        try
                        {
                            var v = method.Invoke(null, new object[] { stringValue });
                            propertyInfo.SetValue(newT, v);
                        }
                        catch (TargetInvocationException ex)
                        {
                            throw ex.InnerException ?? ex;
                        }
                    }
                    else
                    {
                        throw new NotSupportedException(propertyType.Name);
                    }
                }
            }
        }

        /// <summary>
        /// Deserializes an instance of @type from comma delimited string 
        /// based on names obtained from GetCsvHeader().
        /// </summary>
        /// <returns>Comma delimited enumuration of public R/W property values.</returns>
        public static string ToCsvLine<T>(this T instance)
        {
            return
                string.Join(
                    ",",
                    instance.GetType()
                        .GetProperties(BindingFlags.Instance | BindingFlags.Public)
                        .Where(_ => _.CanRead || _.CanWrite)
                        .Select(_ => localEscape(_.GetValue(instance)?.ToString() ?? string.Empty)));
            string localEscape(string mightHaveCommas)
            {
                if (mightHaveCommas.Contains(","))
                {
                    return $@"""{mightHaveCommas}""";
                }
                else return mightHaveCommas;
            }
        }
        public static string GetHeaderText(this PropertyInfo propertyInfo)
        {
            if (propertyInfo.GetCustomAttribute<HeaderTextAttribute>() is HeaderTextAttribute attr)
            {
                return attr.Value.Trim();
            }
            else
            {
                return propertyInfo.Name;
            }
        }
        private static string[] getQualifiedCsvHeaderArrayFromString(this Type type, string headerLine)
        {
            var qualifiedHeaderNames = type.GetCsvPropertyMap();
            //var names = headerLine.Split(',').Where(_=>;
            return default;
        }

        private static Dictionary<Type, KnownTypeInfo> KnownTypeDict { get; } =
            new Dictionary<Type, KnownTypeInfo>();
        private class KnownTypeInfo
        {
            public KnownTypeInfo(Type type)
            {
                var notIgnoredProperties = @type
                    .GetProperties(BindingFlags.Instance | BindingFlags.Public)
                    .Where(_ => !Attribute.IsDefined(_, typeof(CsvIgnoreAttribute)))
                    .Where(_ => _.CanRead || _.CanWrite)
                    .ToArray();

                CsvHeaderArray =
                    notIgnoredProperties
                    .Select(_ => _.GetHeaderText())
                    .ToArray();

                CsvHeader = string.Join(", ", CsvHeaderArray);

                for (int i = 0; i < CsvHeaderArray.Length; i++)
                {
                    string normal = CsvHeaderArray[i], lower = normal.ToLower();
                    CsvPropertyMap[normal] = notIgnoredProperties[i];
                    if (!string.Equals(normal, lower, StringComparison.Ordinal))
                    {
                        CsvPropertyMap[lower] = notIgnoredProperties[i];
                    }
                }
            }
            public string CsvHeader { get; }
            public string[] CsvHeaderArray { get; }
            public Dictionary<string, PropertyInfo> CsvPropertyMap { get; } = new Dictionary<string, PropertyInfo>();
        }
    }
    public class CsvIgnoreAttribute : Attribute { }
    public class HeaderTextAttribute : Attribute
    {
        public HeaderTextAttribute(string value) => Value = value;
        public string Value { get; }
    }
}