
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;

namespace IVSoftware.Portable.Csv
{
    public static class Extensions
    {
        /// <summary>
        /// Enumerates the public R/W property names of an instance of @type as comma-delimites string.
        /// </summary>
        /// <returns>Comma delimited list of names.</returns>
        public static string GetCsvHeader(this Type @type)
        {
            KnownTypeInfo info;
            if (!KnownTypeDict.TryGetValue(@type, out info))
            {
                info = new KnownTypeInfo(@type);
            }
            return info.CsvHeader;
        }
        /// <summary>
        /// Enumerates the public R/W property names of an instance of @type as string array.
        /// </summary>
        /// <returns>String array of names.</returns>
        public static string[] GetCsvHeaderArray(this Type @type)
        {
            KnownTypeInfo info;
            if (!KnownTypeDict.TryGetValue(@type, out info))
            {
                info = new KnownTypeInfo(@type);
            }
            return info.CsvHeaderArray;
        }
        /// <summary>
        /// Enumerates the public R/W property names of an instance of @type.
        /// </summary>
        /// <returns>String array of names.</returns>
        public static Dictionary<string, PropertyInfo> GetCsvPropertyMap(this Type type)
        {
            KnownTypeInfo info;
            if (!KnownTypeDict.TryGetValue(type, out info))
            {
                info = new KnownTypeInfo(type);
                KnownTypeDict[type] = info;
            }
            return info.CsvPropertyMap;
        }

        const string IGNORE_ESCAPED_COMMAS_PATTERN = @",(?=(?:[^""]*""[^""]*"")*(?![^""]*""))";

        /// <summary>
        /// Strict deserialization of an instance of @type from comma delimited string
        /// when header line is generated by GetCsvHeader() or is identical to it.
        /// </summary>
        /// <returns>Instance of type T</returns>
        public static T FromCsvLine<T>(this Type @type, string csvLine)
            where T : new()
        {
            if (csvLine == type.GetCsvHeader())
            {
                // Can't make an instance of T from the header row.
                return default;
            }
            else
            {
                var CsvHeaderNames = type.GetCsvHeaderArray();
                var newT = Activator.CreateInstance<T>();
                var values = Regex.Split(csvLine, IGNORE_ESCAPED_COMMAS_PATTERN);
                for (int i = 0; i < CsvHeaderNames.Length; i++)
                {
                    var propertyName = CsvHeaderNames[i];
                    var value = removeOutsideQuotes(values[i]);
                    if (@type.GetProperty(propertyName) is PropertyInfo pi)
                    {
                        setValue(newT, value, pi);
                    }
                }
                return newT;
            }
        }

        /// <summary>
        /// Fuzzy deserialization of an instance of @type from comma delimited string, meaning
        /// that it's tolerant of names in header that aren't directly mapped to the object.
        /// </summary>
        /// <returns>Instance of type T</returns>
        public static T Extract<T>(this Type @type, string unqualifiedHeader, string csvLine, bool ignoreCase = false)
            where T : new()
        {
            if (csvLine == unqualifiedHeader)
            {
                // Can't make an instance of T from the header row.
                return default;
            }
            else
            {
                var csvHeaderNames = unqualifiedHeader.Split(',').Select(_ => _.Trim()).ToArray();
                var map = type.GetCsvPropertyMap();
                var newT = Activator.CreateInstance<T>();
                var values = Regex.Split(csvLine, IGNORE_ESCAPED_COMMAS_PATTERN);
                for (int i = 0; i < csvHeaderNames.Length; i++)
                {
                    var propertyName = csvHeaderNames[i];
                    if (map.TryGetValue(ignoreCase ? propertyName.ToLower() : propertyName, out var propertyInfo))
                    {
                        var stringValue = removeOutsideQuotes(values[i]);

                        setValue(newT: newT, stringValue: stringValue, propertyInfo: propertyInfo);
                    }
                }
                return newT;
            }
        }

        private static string removeOutsideQuotes(string s)
        {
            if (s.Contains(',') && s.StartsWith("\"") && s.EndsWith("\""))
            {
                return s.Substring(1, s.Length - 2);
            }
            else return s;
        }

        private static void setValue<T>(T newT, string stringValue, PropertyInfo propertyInfo) where T : new()
        {
            if (propertyInfo.CanWrite)
            {
                Type propertyType;
                // For Nullable types, we care only about the underlying type.
                if (Nullable.GetUnderlyingType(propertyInfo.PropertyType) is Type underlyingType)
                {
                    propertyType = underlyingType;
                }
                else
                {
                    propertyType = propertyInfo.PropertyType;
                }

                if (propertyType.Equals(typeof(Object)))
                {
                    // For type Object, assign value as string
                    propertyInfo.SetValue(newT, stringValue);
                }
                else if (propertyType.Equals(typeof(String)))
                {
                    // For type String, assign the value even if it's empty or null
                    propertyInfo.SetValue(newT, stringValue);
                }
                else
                {
                    // If the value is empty, don't assign anything
                    if (string.IsNullOrEmpty(stringValue))
                    {
                        return;
                    }
                    else
                    {
                        if (propertyInfo.GetCustomAttribute<StringFormatAttribute>() is StringFormatAttribute attr)
                        {
                            if (propertyType.GetMethod("ParseExact", new[] { typeof(string), typeof(string), typeof(IFormatProvider) }) is MethodBase methodWithFormatProvider)
                            {
                                if (methodWithFormatProvider?.IsStatic == true)
                                {
                                    try
                                    {
                                        var v = methodWithFormatProvider.Invoke(null, new object[] { stringValue, attr.Value, CultureInfo.InvariantCulture });
                                        propertyInfo.SetValue(newT, v);
                                    }
                                    catch (TargetInvocationException ex)
                                    {
                                        throw ex.InnerException ?? ex;
                                    }
                                }
                                else
                                {
                                    throw new NotSupportedException(propertyType.Name);
                                }
                                return;
                            }
                        }
                        // 'Not' an else. It's a fallback in case an IFormatProvider method is not located.
                        var method = propertyType.GetMethod("Parse", new[] { typeof(string) });
                        if (method?.IsStatic == true)
                        {
                            try
                            {
                                var v = method.Invoke(null, new object[] { stringValue });
                                propertyInfo.SetValue(newT, v);
                            }
                            catch (TargetInvocationException ex)
                            {
                                throw ex.InnerException ?? ex;
                            }
                        }
                        else
                        {
                            throw new NotSupportedException(propertyType.Name);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Deserializes an instance of @type from comma delimited string 
        /// based on names obtained from GetCsvHeader().
        /// </summary>
        /// <returns>Comma delimited enumuration of public R/W property values.</returns>
        public static string ToCsvLine<T>(this T instance)
        {
            var builder = new List<string>();

            foreach (var propertyInfo in instance.GetType()
                        .GetProperties(BindingFlags.Instance | BindingFlags.Public)
                        .Where(_ => (_.CanRead || _.CanWrite) && _.GetCustomAttribute<CsvIgnoreAttribute>() == null))
            {
                if (propertyInfo.GetValue(instance, null) is object value)
                {
                    if (value is IFormattable canFormat && propertyInfo.GetCustomAttribute<StringFormatAttribute>() is StringFormatAttribute attr)
                    {
                        builder.Add(canFormat.ToString(attr.Value ?? string.Empty, CultureInfo.InvariantCulture));
                    }
                    else
                    {
                        builder.Add(localEscape(value?.ToString()));
                    }
                }
                else builder.Add(string.Empty);
            }
            return string.Join(",", builder);

            string localEscape(string mightHaveCommas)
            {
                if (mightHaveCommas.Contains(","))
                {
                    return $@"""{mightHaveCommas}""";
                }
                else return mightHaveCommas;
            }
        }
        public static string GetHeaderText(this PropertyInfo propertyInfo)
        {
            if (propertyInfo.GetCustomAttribute<HeaderTextAttribute>() is HeaderTextAttribute attr)
            {
                return attr.Value.Trim();
            }
            else
            {
                return propertyInfo.Name;
            }
        }

        public static string[] GetAllLines<T>(this IEnumerable<T> collection)
        {
            List<string> lines = new List<string> { GetCsvHeader(typeof(T)) };
            lines.AddRange(collection.Select(_=>_.ToCsvLine()));
            return lines.ToArray();
        }

        private static Dictionary<Type, KnownTypeInfo> KnownTypeDict { get; } =
            new Dictionary<Type, KnownTypeInfo>();
        private class KnownTypeInfo
        {
            public KnownTypeInfo(Type type)
            {
                var notIgnoredProperties = @type
                    .GetProperties(BindingFlags.Instance | BindingFlags.Public)
                    .Where(_ => !Attribute.IsDefined(_, typeof(CsvIgnoreAttribute)))
                    .Where(_ => _.CanRead || _.CanWrite)
                    .ToArray();

                CsvHeaderArray =
                    notIgnoredProperties
                    .Select(_ => _.GetHeaderText())
                    .ToArray();

                CsvHeader = string.Join(", ", CsvHeaderArray);

                for (int i = 0; i < CsvHeaderArray.Length; i++)
                {
                    string normal = CsvHeaderArray[i], lower = normal.ToLower();
                    CsvPropertyMap[normal] = notIgnoredProperties[i];
                    if (!string.Equals(normal, lower, StringComparison.Ordinal))
                    {
                        CsvPropertyMap[lower] = notIgnoredProperties[i];
                    }
                }
            }
            public string CsvHeader { get; }
            public string[] CsvHeaderArray { get; }
            public Dictionary<string, PropertyInfo> CsvPropertyMap { get; } = new Dictionary<string, PropertyInfo>();
        }
    }

    /// <summary>
    /// Opt-out this property from Header and Instance serialization.
    /// </summary>
    public class CsvIgnoreAttribute : Attribute { }


    /// <summary>
    /// Header text mapping, if different from Property name or if spaces are present.
    /// </summary>
    public class HeaderTextAttribute : Attribute
    {
        public HeaderTextAttribute(string value) => Value = value;
        public string Value { get; }
    }

    /// <summary>
    /// Format string for ToString() and ParseExact methods
    /// </summary>
    public class StringFormatAttribute : Attribute
    {
        public StringFormatAttribute(string value) => Value = value;
        public string Value { get; }
    }
}